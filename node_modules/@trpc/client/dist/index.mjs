import { share, observableToPromise } from '@trpc/server/observable';
import { T as TRPCClientError } from './transformResult-106791d7.mjs';
export { T as TRPCClientError } from './transformResult-106791d7.mjs';
import { c as createChain } from './splitLink-ad44a55d.mjs';
export { s as splitLink } from './splitLink-ad44a55d.mjs';
import { httpBatchLink } from './links/httpBatchLink.mjs';
export { httpBatchLink } from './links/httpBatchLink.mjs';
import { createRecursiveProxy } from '@trpc/server/shared';
export { g as getFetch } from './httpUtils-d1885508.mjs';
export { httpLink } from './links/httpLink.mjs';
export { loggerLink } from './links/loggerLink.mjs';
export { createWSClient, wsLink } from './links/wsLink.mjs';

class TRPCClient {
    $request({ type , input , path , context ={}  }) {
        const chain$ = createChain({
            links: this.links,
            op: {
                id: ++this.requestId,
                type,
                path,
                input,
                context
            }
        });
        return chain$.pipe(share());
    }
    requestAsPromise(opts) {
        const req$ = this.$request(opts);
        const { promise , abort  } = observableToPromise(req$);
        const abortablePromise = new Promise((resolve, reject)=>{
            opts.signal?.addEventListener('abort', abort);
            promise.then((envelope)=>{
                resolve(envelope.result.data);
            }).catch((err)=>{
                reject(TRPCClientError.from(err));
            });
        });
        return abortablePromise;
    }
    query(path, input, opts) {
        return this.requestAsPromise({
            type: 'query',
            path,
            input: input,
            context: opts?.context,
            signal: opts?.signal
        });
    }
    mutation(path, input, opts) {
        return this.requestAsPromise({
            type: 'mutation',
            path,
            input: input,
            context: opts?.context,
            signal: opts?.signal
        });
    }
    subscription(path, input, opts) {
        const observable$ = this.$request({
            type: 'subscription',
            path,
            input,
            context: opts?.context
        });
        return observable$.subscribe({
            next (envelope) {
                if (envelope.result.type === 'started') {
                    opts.onStarted?.();
                } else if (envelope.result.type === 'stopped') {
                    opts.onStopped?.();
                } else {
                    opts.onData?.(envelope.result.data);
                }
            },
            error (err) {
                opts.onError?.(err);
            },
            complete () {
                opts.onComplete?.();
            }
        });
    }
    constructor(opts){
        this.requestId = 0;
        function getTransformer() {
            if (!opts.transformer) return {
                serialize: (data)=>data,
                deserialize: (data)=>data
            };
            if ('input' in opts.transformer) return {
                serialize: opts.transformer.input.serialize,
                deserialize: opts.transformer.output.deserialize
            };
            return opts.transformer;
        }
        this.runtime = {
            transformer: getTransformer()
        };
        // Initialize the links
        this.links = opts.links.map((link)=>link(this.runtime));
    }
}

/**
 * @deprecated use `createTRPCProxyClient` instead
 */ function createTRPCClient(opts) {
    const getLinks = ()=>{
        if ('links' in opts) {
            return opts.links;
        }
        return [
            httpBatchLink(opts)
        ];
    };
    const client = new TRPCClient({
        transformer: opts.transformer,
        links: getLinks()
    });
    return client;
}

const clientCallTypeMap = {
    query: 'query',
    mutate: 'mutation',
    subscribe: 'subscription'
};
/**
 * @deprecated use `createTRPCProxyClient` instead
 * @internal
 */ function createTRPCClientProxy(client) {
    const proxy = createRecursiveProxy(({ path , args  })=>{
        const pathCopy = [
            ...path
        ];
        const clientCallType = pathCopy.pop();
        const procedureType = clientCallTypeMap[clientCallType];
        const fullPath = pathCopy.join('.');
        return client[procedureType](fullPath, ...args);
    });
    return proxy;
}
function createTRPCProxyClient(opts) {
    const client = new TRPCClient(opts);
    const proxy = createTRPCClientProxy(client);
    return proxy;
}

export { createTRPCClient, createTRPCClientProxy, createTRPCProxyClient };
